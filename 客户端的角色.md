客户端向系统中增加任务。在本例中，我们不关心任务的实际组成。现在我们假设客户端需要master-worker系统运行一个命令cmd。要在系统中增加一个任务，客户端执行下面的命令：

`[zk: localhost:2181(CONNECTED) 0] create -s /tasks/task- "cmd"`

`Created /tasks/task-0000000000`

为了让新增的任务有顺序，我们让任务节点是顺序性的，自然就形成了一个队列。客户端现在不得不等到任务被执行。一旦任务完成，那个执行任务的worker就会为task创建一个状态节点。当客户端看到任务的状态节点被创建时认为任务已经被执行了。自然，客户端需要监视状态节点的创建：

`[zk: localhost:2181(CONNECTED) 1] ls /tasks/task-0000000000 true`

`[]`

`[zk: localhost:2181(CONNECTED) 2]`

执行任务的worker创建了一个孩子节点\/tasks\/task-0000000000。这就是通过ls命令来监视\/tasks\/task-0000000000孩子节点的原因。

一旦任务节点被创建了，master就会观察到下面的事件：

`[zk: localhost:2181(CONNECTED) 6]`

`WATCHER::`

`WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/tasks`

master接下来检查新的任务，获取可用的worker列表，并把它指派给worker1.example.com:

`[zk: 6] ls /tasks`

`[task-0000000000]`

`[zk: 7] ls /workers`

`[worker1.example.com]`

`[zk: 8] create /assign/worker1.example.com/task-0000000000 ""`

`Created /assign/worker1.example.com/task-0000000000`

`[zk: 9]`

worker接着收到一个新任务被分配的通知：

`[zk: localhost:2181(CONNECTED) 3]`

`WATCHER::`

`WatchedEvent state:SyncConnected type:NodeChildrenChanged`

`path:/assign/worker1.example.com`

worker然后检查新的任务，看看任务是否被分配给它：

`WATCHER::`

`WatchedEvent state:SyncConnected type:NodeChildrenChanged`

`path:/assign/worker1.example.com`

`[zk: localhost:2181(CONNECTED) 3] ls /assign/worker1.example.com`

`[task-0000000000]`

`[zk: localhost:2181(CONNECTED) 4]`



