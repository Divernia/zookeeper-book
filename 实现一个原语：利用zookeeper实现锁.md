使用Zookeeper的一个简单例子就是通过锁来实现临界区。目前有多种锁（如读写锁，全局锁），使用Zookeeper来实现锁也有多种方式。这里我们讨论一个简单的秘方来说明应用如何使用Zookeeper，不考虑其它锁的变体。

假设我们现在有一个应用，其中有n个进程尝试获取一个锁。回想到Zookeeper是不直接暴露原语，所以我们需要使用Zookeeper的接口来操作一个znode以此来实现一个锁。为了得到锁，每个进程p都尝试创建一个znode节点，例如\/lock。如果p成功地创建了节点，那么它就获得了锁，也就能执行它的临界区的代码了。一个潜在的问题是进程p可能会奔溃，永远不会释放锁。这种情况下，没有其他的进程能够再次获取锁，系统可能会死锁。为了避免这种情况，当我们创建它的时候必须让\/lock节点是临时节点。

只要节点存在，其他想创建\/lock节点进程都会失败。所以，它们监视\/lock节点的变化，一旦它们检测到了\/lock节点被删除了就会再次尝试获取锁。当收到\/lock节点被删除的通知时，如果进程p'还对获取锁感兴趣的话，它会重复创建\/lock节点的步骤。如果另外一个进程已经创建了节点，那么继续监视它。

